# WordPress Plugin Development Rules

## Core Standards

- Follow WordPress Coding Standards (WPCS) for all PHP code
- Use PHP 7.4+ syntax with full type hints where possible
- Use namespaces to avoid conflicts: `namespace YourCompany\YourPlugin`
- Organize code into single-responsibility classes
- No inline JavaScript in PHP output; always enqueue scripts

## Security (Non-negotiable)

- EVERY form/AJAX: Validate with `wp_verify_nonce()`
- EVERY database query: Use `$wpdb->prepare()` for parameters
- EVERY user input: Sanitize with `sanitize_*()` before use
- EVERY output: Escape with `esc_html()`, `esc_attr()`, `esc_js()`, `wp_json_encode()`
- EVERY capability check: Use `current_user_can()` before sensitive operations
- Never use `eval()`, `extract()`, or `include()` with user input

## File Organization

plugin-name/
├── plugin-name.php          (main plugin file, minimal code)
├── uninstall.php            (cleanup on uninstall)
├── .windsurfrules           (this file)
├── .phpcs.xml               (linting config)
├── composer.json            (PHP dependencies)
├── package.json             (npm dependencies)
├── CHANGELOG.md             (version history)
├── README.md                (plugin documentation)
├── /includes/               (core plugin classes)
│   ├── class-activator.php
│   ├── class-deactivator.php
│   ├── class-loader.php
│   └── ...other classes
├── /admin/                  (admin-only functionality)
│   ├── class-admin-menu.php
│   ├── class-settings.php
│   ├── /partials/           (admin page templates)
│   └── /tabs/               (settings tab classes, if using tabbed UI)
├── /public/                 (frontend functionality)
│   ├── class-frontend.php
│   └── /partials/           (frontend templates)
├── /assets/
│   ├── /src/                (source files - edit these)
│   │   ├── /admin/          (admin JS/CSS source)
│   │   ├── /frontend/       (frontend JS/CSS source)
│   │   └── /shared/         (shared modules)
│   ├── /dist/               (compiled output - do not edit)
│   └── /images/
├── /languages/              (translation files)
├── /tests/                  (PHPUnit tests)
├── /docs/                   (documentation)
│   └── SETTINGS.md          (settings schema reference)
├── /scripts/
│   └── build.mjs            (build script)
└── .gitignore

## Architecture Patterns

### Classes vs Traits

- Use **classes** for distinct objects with their own identity
- Use **traits** to compose shared functionality into classes
- Split into traits when a class exceeds ~300 lines
- Organize traits by concern:

/includes/Admin/
├── /Render/           (field/section rendering methods)
├── /Settings/
│   ├── /Sanitize/     (sanitization/validation methods)
│   └── Schema.php     (option schema definitions)
└── Ajax.php           (AJAX handlers)
- Trait naming: `{Plugin}_{Category}_{Name}_Trait`

### REST API Structure

For plugins with REST endpoints, use focused service classes:

/includes/Rest/
├── class-api.php            (orchestrator - registers routes, delegates to services)
├── class-{service}.php      (single-purpose service classes)
└── /Clients/                (third-party API clients)
└── class-{api}-client.php

Principle: The orchestrator registers routes and delegates to services. Services handle one concern each.

## Class Naming & Structure

- Classes: `{Plugin}_{Category}_{Name}`
- Traits: `{Plugin}_{Category}_{Name}_Trait`
- Functions: `{plugin_slug}_{action}()`
- Options: `{plugin_slug}_{setting_name}`
- Transients: `{plugin_slug}_{purpose}_{identifier}`
- All classes should have single responsibility
- Use dependency injection for loose coupling

## Hooks & Extensibility

- Define custom hooks in separate documentation block at class top
- Custom action hook naming: `{plugin_slug}_{context}_{action}`
- Custom filter hook naming: `{plugin_slug}_{context}_{noun}`
- Example: `apply_filters( 'my_plugin_user_data', $data )`

## Database Operations

- Use `$wpdb->prepare()` for ALL variable interpolation
- Register tables in `register_activation_hook` callback
- Add migration system for schema changes
- Store plugin metadata in wp_options with prefix
- Clean up all data in `uninstall.php`

## Asset Management

### Source & Build Structure
- Source files in `/assets/src/` (edit these)
- Built files in `/assets/dist/` (never edit)
- Run build after any JS/CSS changes

### Enqueuing
- Enqueue in `wp_enqueue_scripts` (frontend) or `admin_enqueue_scripts` (admin)
- Use version hash for cache busting: `filemtime( $file )`
- Load CSS before JS
- Use `wp_localize_script()` for JS configuration

### JavaScript
- Use ES6 modules with named exports
- No jQuery in new code (vanilla JS only)
- Configuration via `wp_localize_script`: `const config = window.pluginConfig || {}`

### CSS
- BEM-style naming: `.{plugin}-{block}__element--modifier`
- Use CSS custom properties for theming

## Settings & Options

### General
- Store configuration with unique prefix: `get_option( 'my_plugin_settings' )`
- Sanitize on save, validate on retrieve
- Use WordPress Settings API for admin pages
- Include descriptions and help text for all settings

### Settings Schema
- Maintain a central schema (e.g., `/includes/Admin/Settings/Schema.php` or `/docs/SETTINGS.md`)
- Map each option to: key, type, default, sanitization method, which tab it belongs to
- This prevents orphaned options and aids debugging

### Tabbed Settings Warning
If using tabbed settings (WooCommerce-style), be aware of cross-tab data loss:

> **Warning:** Saving one tab can wipe options registered on other tabs. Implement a guard that preserves options not belonging to the current tab being saved. Map each option to its tab in your schema.

## Internationalization (i18n)

- Use `__( 'text', 'plugin-slug' )` for strings
- Use `_e( 'text', 'plugin-slug' )` for echoed output
- Use `_n( singular, plural, count, 'plugin-slug' )` for plurals
- Never hardcode translatable strings

## Version Management

- Store version as `define( 'PLUGIN_VERSION', '1.0.0' )` in main plugin file
- Use semantic versioning (MAJOR.MINOR.PATCH)
- Update CHANGELOG.md when version changes

## Code Quality Rules

- Keep files under 300 lines; split into traits/classes when larger
- Keep methods focused on single task
- Use PHP type hints for all function parameters and returns
- Use meaningful variable names (no `$x`, `$temp`)
- Comment "why," not "what" (code should be self-documenting)

## Testing

- Write testable code: dependency injection, no static dependencies
- Organize tests matching `/includes/` structure in `/tests/`
- Test coverage goal: 80%+ of plugin logic
- Use mocked WordPress functions in unit tests
- Brain Monkey returnArg() uses 1-based indexes (use returnArg(1) for first argument)

## Performance

- Minimize database queries; use caching where applicable
- Use transients for expensive operations
- Lazy-load heavy dependencies
- Minify and compress assets in production

## When Generating Code

1. Ask me the plugin purpose and core features
2. Create complete folder structure first
3. Implement with security-first approach
4. Write testable code
5. Include inline comments for non-obvious logic
6. Never leave TODOs; finish what you start

## Workflow Preference

- I tell you what to build
- You write production-ready code, fully implemented
- I run linting/tests to validate
- I request iterations with specific changes

## Do NOT

- Edit files in `assets/dist/` (built output)
- Add inline scripts via `wp_add_inline_script()` in admin settings
- Create files over 300 lines without splitting
- Use jQuery in new code (vanilla JS only)
- Skip sanitization or escaping
- Leave debug code (`console.log`, `var_dump`, `error_log` for debugging)
- Commit to database without prepared statements
- Output user data without escaping
- Process user input without sanitization
- Use global functions that could be namespaced